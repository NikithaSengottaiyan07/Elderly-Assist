"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactNativeVoiceSTTProvider = void 0;
var _voice = _interopRequireDefault(require("@react-native-voice/voice"));
var _reactNative = require("react-native");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class ReactNativeVoiceSTTProvider {
  constructor(locale) {
    _defineProperty(this, "locale", void 0);
    _defineProperty(this, "speechResultsHandlers", []);
    _defineProperty(this, "speechErrorHandlers", []);
    _defineProperty(this, "speechPartialHandlers", []);
    _defineProperty(this, "speechStartHandlers", []);
    _defineProperty(this, "speechRecognizedHandlers", []);
    _defineProperty(this, "speechEndHandlers", []);
    _defineProperty(this, "speechVolumeHandlers", []);
    this.locale = locale;
  }
  initialize(locale) {
    this.locale = locale;
    let timeout;
    //The react native voice package has a bug on ios where it does not wait 
    //for the person to stop talking before firing the callback function
    //this work around sets a timer and fires the handlers if no new words are deteced after 500 ms
    if (_reactNative.Platform.OS == "ios") {
      const onSpeechResults = event => {
        var _this$speechEndHandle, _this$speechResultsHa;
        _voice.default.cancel();
        _voice.default.stop();
        _voice.default.destroy();
        (_this$speechEndHandle = this.speechEndHandlers) === null || _this$speechEndHandle === void 0 || _this$speechEndHandle.forEach(handle => handle(false));
        (_this$speechResultsHa = this.speechResultsHandlers) === null || _this$speechResultsHa === void 0 || _this$speechResultsHa.forEach(handle => event.value && handle(event.value[0]));
      };
      _voice.default.onSpeechResults = event => {
        if (!timeout) {
          timeout = setTimeout(() => {
            onSpeechResults(event);
          }, 900);
        } else {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            onSpeechResults(event);
          }, 900);
        }
      };
    } else if (_reactNative.Platform.OS == "android") {
      _voice.default.onSpeechResults = event => {
        var _this$speechResultsHa2;
        (_this$speechResultsHa2 = this.speechResultsHandlers) === null || _this$speechResultsHa2 === void 0 || _this$speechResultsHa2.forEach(handle => event.value && handle(event.value[0]));
      };
    }
    _voice.default.onSpeechError = event => {
      var _this$speechErrorHand;
      (_this$speechErrorHand = this.speechErrorHandlers) === null || _this$speechErrorHand === void 0 || _this$speechErrorHand.forEach(handle => {
        var _event$error;
        return ((_event$error = event.error) === null || _event$error === void 0 ? void 0 : _event$error.message) && handle(event.error.message);
      });
    };
    _voice.default.onSpeechPartialResults = event => {
      var _this$speechPartialHa;
      (_this$speechPartialHa = this.speechPartialHandlers) === null || _this$speechPartialHa === void 0 || _this$speechPartialHa.forEach(handle => event.value && handle(event.value[0]));
    };
    _voice.default.onSpeechStart = event => {
      var _this$speechStartHand;
      (_this$speechStartHand = this.speechStartHandlers) === null || _this$speechStartHand === void 0 || _this$speechStartHand.forEach(handle => handle(event === null || event === void 0 ? void 0 : event.error));
    };
    _voice.default.onSpeechRecognized = event => {
      var _this$speechRecognize;
      (_this$speechRecognize = this.speechRecognizedHandlers) === null || _this$speechRecognize === void 0 || _this$speechRecognize.forEach(handle => event.isFinal && handle(event.isFinal));
    };
    _voice.default.onSpeechEnd = event => {
      var _this$speechEndHandle2;
      (_this$speechEndHandle2 = this.speechEndHandlers) === null || _this$speechEndHandle2 === void 0 || _this$speechEndHandle2.forEach(handle => handle(event === null || event === void 0 ? void 0 : event.error));
    };
    _voice.default.onSpeechVolumeChanged = event => {
      var _this$speechVolumeHan;
      (_this$speechVolumeHan = this.speechVolumeHandlers) === null || _this$speechVolumeHan === void 0 || _this$speechVolumeHan.forEach(handle => event.value && handle(event.value));
    };
  }
  startListening() {
    _voice.default.start(this.locale);
  }
  stopListening() {
    _voice.default.stop();
  }
  cancelListening() {
    _voice.default.cancel();
  }
  destroyInstance() {
    _voice.default.destroy();
  }
  removeAllListeners() {
    _voice.default.removeAllListeners();
  }
  async isVoiceAvailable() {
    const isVoiceAvailable = await _voice.default.isAvailable();
    if (isVoiceAvailable == 0) {
      return false;
    } else {
      return true;
    }
  }
  async isRecognizing() {
    const isRecognizing = await _voice.default.isRecognizing();
    if (isRecognizing == 0) {
      return false;
    } else {
      return true;
    }
  }
  async getSpeechRecognitionServices() {
    const services = await _voice.default.getSpeechRecognitionServices();
    if (services) {
      return services;
    } else {
      return [''];
    }
  }
  addFinishListener(callback) {
    var _this$speechResultsHa3;
    (_this$speechResultsHa3 = this.speechResultsHandlers) === null || _this$speechResultsHa3 === void 0 || _this$speechResultsHa3.push(callback);
  }
  addErrorListener(callback) {
    var _this$speechErrorHand2;
    (_this$speechErrorHand2 = this.speechErrorHandlers) === null || _this$speechErrorHand2 === void 0 || _this$speechErrorHand2.push(callback);
  }
  addPartialListener(callback) {
    var _this$speechPartialHa2;
    (_this$speechPartialHa2 = this.speechPartialHandlers) === null || _this$speechPartialHa2 === void 0 || _this$speechPartialHa2.push(callback);
  }
  addStartListener(callback) {
    var _this$speechStartHand2;
    (_this$speechStartHand2 = this.speechStartHandlers) === null || _this$speechStartHand2 === void 0 || _this$speechStartHand2.push(callback);
  }
  addRecognizedListener(callback) {
    var _this$speechRecognize2;
    (_this$speechRecognize2 = this.speechRecognizedHandlers) === null || _this$speechRecognize2 === void 0 || _this$speechRecognize2.push(callback);
  }
  addEndListener(callback) {
    var _this$speechEndHandle3;
    (_this$speechEndHandle3 = this.speechEndHandlers) === null || _this$speechEndHandle3 === void 0 || _this$speechEndHandle3.push(callback);
  }
  addVolumeListener(callback) {
    var _this$speechVolumeHan2;
    (_this$speechVolumeHan2 = this.speechVolumeHandlers) === null || _this$speechVolumeHan2 === void 0 || _this$speechVolumeHan2.push(callback);
  }
  clearHandlers() {
    this.speechResultsHandlers = [];
    this.speechErrorHandlers = [];
    this.speechPartialHandlers = [];
    this.speechStartHandlers = [];
    this.speechEndHandlers = [];
    this.speechRecognizedHandlers = [];
    this.speechVolumeHandlers = [];
  }
}
exports.ReactNativeVoiceSTTProvider = ReactNativeVoiceSTTProvider;
//# sourceMappingURL=ReactNativeVoiceSTTProvider.js.map