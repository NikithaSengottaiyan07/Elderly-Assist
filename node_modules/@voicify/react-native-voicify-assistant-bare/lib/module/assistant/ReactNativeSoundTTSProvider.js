function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import Sound from 'react-native-sound';
export class ReactNativeSoundTTSProvider {
  constructor(settings) {
    _defineProperty(this, "settings", void 0);
    _defineProperty(this, "audioPlayer", void 0);
    _defineProperty(this, "speechEndHandlers", []);
    _defineProperty(this, "cancel", void 0);
    this.settings = settings;
  }
  initialize(locale) {
    this.settings.locale = locale;
  }
  createLinkedList(src) {
    let top = {};
    for (let i = src.length - 1; i >= 0; i--) {
      if (i == src.length - 1) {
        top = {
          src: src[i].url,
          next: {}
        };
      } else {
        let temp = {
          src: src[i].url,
          next: top
        };
        top = temp;
      }
    }
    return top;
  }
  playNext(linkedSrc) {
    this.audioPlayer = new Sound(linkedSrc.src, "", error => {
      if (error) {
        return;
      }
      if (this.audioPlayer) {
        if (!this.cancel) {
          this.audioPlayer.play(success => {
            if (success) {
              var _linkedSrc$next;
              if ((_linkedSrc$next = linkedSrc.next) !== null && _linkedSrc$next !== void 0 && _linkedSrc$next.src) {
                this.playNext(linkedSrc.next);
              } else {
                var _this$speechEndHandle;
                (_this$speechEndHandle = this.speechEndHandlers) === null || _this$speechEndHandle === void 0 || _this$speechEndHandle.forEach(handle => handle());
              }
            }
          });
        }
      }
    });
  }
  async speakSsml(ssml) {
    let linkedLists = {};
    const ssmlUri = await this.ssmlToSpeech(ssml);
    if (ssmlUri) {
      linkedLists = this.createLinkedList(ssmlUri);
    }
    if (linkedLists) {
      this.playNext(linkedLists);
    }
  }
  async stop() {
    if (this.audioPlayer) {
      this.audioPlayer.stop();
    }
  }
  async ssmlToSpeech(ssml) {
    try {
      const textToSpeechRequest = this.generateTTSRequest(ssml);
      const result = await fetch(`${this.settings.serverRootUrl}/api/Ssml/toSpeech/${this.settings.provider}`, {
        method: "POST",
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(textToSpeechRequest)
      });
      if (result.status == 200) {
        const response = await result.json();
        return response;
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  }
  generateTTSRequest(ssml) {
    const request = {
      applicationId: this.settings.appId,
      applicationSecret: this.settings.appKey,
      ssmlRequest: {
        ssml: ssml,
        locale: this.settings.locale,
        voice: this.settings.voice
      }
    };
    return request;
  }
  addFinishListener(callback) {
    var _this$speechEndHandle2;
    (_this$speechEndHandle2 = this.speechEndHandlers) === null || _this$speechEndHandle2 === void 0 || _this$speechEndHandle2.push(callback);
  }
  clearHandlers() {
    this.speechEndHandlers = [];
  }
}
//# sourceMappingURL=ReactNativeSoundTTSProvider.js.map