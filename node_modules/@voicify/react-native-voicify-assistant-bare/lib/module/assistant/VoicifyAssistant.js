function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
//TO DO: use the assistant SDK from NPM once it is ready instead of having seperate files
export class VoicifyAssistant {
  constructor(settings, ttsProvider, sttProvider) {
    _defineProperty(this, "textToSpeechProvider", void 0);
    _defineProperty(this, "speechToTextProvider", void 0);
    _defineProperty(this, "settings", void 0);
    _defineProperty(this, "sessionId", void 0);
    _defineProperty(this, "userId", void 0);
    _defineProperty(this, "accessToken", void 0);
    _defineProperty(this, "sessionAttributes", void 0);
    _defineProperty(this, "userAttributes", void 0);
    _defineProperty(this, "errorHandlers", []);
    _defineProperty(this, "effectHandlers", []);
    _defineProperty(this, "requestStartedHandlers", []);
    _defineProperty(this, "responseHandlers", []);
    _defineProperty(this, "endSessionHandlers", []);
    _defineProperty(this, "audioHandlers", []);
    _defineProperty(this, "videoHandlers", []);
    _defineProperty(this, "currentSessionInfo", void 0);
    _defineProperty(this, "currentUserInfo", void 0);
    this.speechToTextProvider = sttProvider;
    this.textToSpeechProvider = ttsProvider;
    this.settings = settings;
  }
  initializeAndStart() {
    var _this$textToSpeechPro, _this$speechToTextPro;
    (_this$textToSpeechPro = this.textToSpeechProvider) === null || _this$textToSpeechPro === void 0 || _this$textToSpeechPro.initialize(this.settings.locale);
    (_this$speechToTextPro = this.speechToTextProvider) === null || _this$speechToTextPro === void 0 || _this$speechToTextPro.initialize(this.settings.locale);
  }
  startNewSession(sessionId, userId, sessionAttributes, userAttributes) {
    var _this$settings;
    this.sessionId = sessionId ?? uuidv4();
    this.userId = userId ?? this.userId ?? uuidv4();
    this.sessionAttributes = sessionAttributes;
    this.userAttributes = userAttributes;
    this.currentSessionInfo = {};
    this.currentUserInfo = {};
    if ((_this$settings = this.settings) !== null && _this$settings !== void 0 && _this$settings.initializeWithWelcomeMessage) this.makeWelcomeRequest();
  }
  onEffect(effectName, callback) {
    var _this$effectHandlers;
    (_this$effectHandlers = this.effectHandlers) === null || _this$effectHandlers === void 0 || _this$effectHandlers.push({
      effect: effectName,
      callback
    });
  }
  onError(callback) {
    var _this$errorHandlers;
    (_this$errorHandlers = this.errorHandlers) === null || _this$errorHandlers === void 0 || _this$errorHandlers.push(callback);
  }
  onRequestStarted(callback) {
    var _this$requestStartedH;
    (_this$requestStartedH = this.requestStartedHandlers) === null || _this$requestStartedH === void 0 || _this$requestStartedH.push(callback);
  }
  onResponseReceived(callback) {
    var _this$responseHandler;
    (_this$responseHandler = this.responseHandlers) === null || _this$responseHandler === void 0 || _this$responseHandler.push(callback);
  }
  onSessionEnded(callback) {
    var _this$endSessionHandl;
    (_this$endSessionHandl = this.endSessionHandlers) === null || _this$endSessionHandl === void 0 || _this$endSessionHandl.push(callback);
  }
  onPlayVideo(callback) {
    var _this$videoHandlers;
    (_this$videoHandlers = this.videoHandlers) === null || _this$videoHandlers === void 0 || _this$videoHandlers.push(callback);
  }
  onPlayAudio(callback) {
    var _this$audioHandlers;
    (_this$audioHandlers = this.audioHandlers) === null || _this$audioHandlers === void 0 || _this$audioHandlers.push(callback);
  }
  clearHandlers() {
    this.audioHandlers = [];
    this.videoHandlers = [];
    this.responseHandlers = [];
    this.requestStartedHandlers = [];
    this.errorHandlers = [];
    this.effectHandlers = [];
    this.endSessionHandlers = [];
  }
  makeTextRequest(text, requestAttributes, inputType) {
    const request = this.generateTextRequest(text, requestAttributes);
    return this.makeRequest(request, inputType);
  }
  makeWelcomeRequest(requestAttributes) {
    const request = this.generateWelcomeRequest(requestAttributes);
    return this.makeRequest(request);
  }
  addSessionAttribute(key, value) {
    if (!this.sessionAttributes) this.sessionAttributes = {};
    this.sessionAttributes[key] = value;
  }
  addUserAttribute(key, value) {
    if (!this.userAttributes) this.userAttributes = {};
    this.userAttributes[key] = value;
  }
  addAccessToken(value) {
    this.accessToken = value;
  }
  async makeRequest(request, inputType) {
    try {
      var _this$textToSpeechPro2, _this$requestStartedH2;
      (_this$textToSpeechPro2 = this.textToSpeechProvider) === null || _this$textToSpeechPro2 === void 0 || _this$textToSpeechPro2.stop();
      (_this$requestStartedH2 = this.requestStartedHandlers) === null || _this$requestStartedH2 === void 0 || _this$requestStartedH2.forEach(handle => handle(request));
      const result = await fetch(`${this.settings.serverRootUrl}/api/customAssistant/handlerequest?applicationId=${this.settings.appId}&applicationSecret=${this.settings.appKey}`, {
        method: "POST",
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(request)
      });
      if (result.status == 200) {
        var _this$textToSpeechPro3, _this$textToSpeechPro4, _this$settings2, _this$responseHandler2, _this$audioHandlers2, _this$videoHandlers2;
        const response = await result.json();
        (_this$textToSpeechPro3 = this.textToSpeechProvider) === null || _this$textToSpeechPro3 === void 0 || _this$textToSpeechPro3.clearHandlers();
        (_this$textToSpeechPro4 = this.textToSpeechProvider) === null || _this$textToSpeechPro4 === void 0 || _this$textToSpeechPro4.addFinishListener(() => {
          if (inputType) {
            var _this$speechToTextPro2;
            this.settings.autoRunConversation && this.settings.useVoiceInput && inputType == 'Speech' && this.settings.useOutputSpeech && this.speechToTextProvider && response.endSession == false && ((_this$speechToTextPro2 = this.speechToTextProvider) === null || _this$speechToTextPro2 === void 0 ? void 0 : _this$speechToTextPro2.startListening());
          }
        });
        if (this.textToSpeechProvider && (_this$settings2 = this.settings) !== null && _this$settings2 !== void 0 && _this$settings2.useOutputSpeech && (response.outputSpeech || response.ssml)) {
          if (response.ssml) {
            this.textToSpeechProvider.speakSsml(response.ssml);
          } else if (response.outputSpeech) {
            this.textToSpeechProvider.speakSsml(`<speak>${response.outputSpeech}</speak>`);
          }
        }
        const effectHandlers = this.effectHandlers;
        fetch(`${this.settings.serverRootUrl}/api/UserProfile/session/${this.sessionId}?applicationId=${this.settings.appId}&applicationSecret=${this.settings.appKey}`, {
          method: "GET",
          headers: {
            'Content-Type': 'application/json'
          }
        }).then(async sessionRes => {
          if (sessionRes.status == 200) {
            var _response$effects, _effects;
            const sessionData = await (sessionRes === null || sessionRes === void 0 ? void 0 : sessionRes.json());
            if (sessionData) this.currentSessionInfo = sessionData;

            // fire effects
            // first check for response effects
            let effects = [];
            if (response !== null && response !== void 0 && (_response$effects = response.effects) !== null && _response$effects !== void 0 && _response$effects.length) {
              effects = response.effects;
            }
            // if no response effects, check for session effects
            else {
              var _sessionData$sessionA;
              effects = (sessionData === null || sessionData === void 0 || (_sessionData$sessionA = sessionData.sessionAttributes) === null || _sessionData$sessionA === void 0 ? void 0 : _sessionData$sessionA["effects"]) ?? [];
            }

            // fire effects if we have any
            if ((_effects = effects) !== null && _effects !== void 0 && _effects.length) {
              var _effects$, _effects$2;
              // if we have the effect "name" prop, fire the response effects
              if ((_effects$ = effects[0]) !== null && _effects$ !== void 0 && _effects$.name) {
                effects.forEach(effect => {
                  var _effectHandlers$filte;
                  (_effectHandlers$filte = effectHandlers.filter(e => e.effect == effect.name)) === null || _effectHandlers$filte === void 0 || _effectHandlers$filte.forEach(handle => handle.callback(effect === null || effect === void 0 ? void 0 : effect.data));
                });
              }
              // otherwise fire the session effects
              else if ((_effects$2 = effects[0]) !== null && _effects$2 !== void 0 && _effects$2.effectName) {
                var _effects2;
                (_effects2 = effects) === null || _effects2 === void 0 || (_effects2 = _effects2.filter(e => e.requestId == request.requestId)) === null || _effects2 === void 0 || _effects2.forEach(effect => {
                  var _effectHandlers$filte2;
                  (_effectHandlers$filte2 = effectHandlers.filter(e => e.effect == effect.effectName)) === null || _effectHandlers$filte2 === void 0 || _effectHandlers$filte2.forEach(handle => handle.callback(effect === null || effect === void 0 ? void 0 : effect.data));
                });
              }
            }
          }
        });
        fetch(`${this.settings.serverRootUrl}/api/UserProfile/${this.userId}?applicationId=${this.settings.appId}&applicationSecret=${this.settings.appKey}`, {
          method: "GET",
          headers: {
            'Content-Type': 'application/json'
          }
        }).then(async userRes => {
          if (userRes.status == 200) {
            const userData = await (userRes === null || userRes === void 0 ? void 0 : userRes.json());
            if (userData) this.currentUserInfo = userData;
          }
        });
        (_this$responseHandler2 = this.responseHandlers) === null || _this$responseHandler2 === void 0 || _this$responseHandler2.forEach(handle => handle(response));
        if (response !== null && response !== void 0 && response.audioFile) (_this$audioHandlers2 = this.audioHandlers) === null || _this$audioHandlers2 === void 0 || _this$audioHandlers2.forEach(handle => handle(response.audioFile));
        if (response !== null && response !== void 0 && response.videoFile) (_this$videoHandlers2 = this.videoHandlers) === null || _this$videoHandlers2 === void 0 || _this$videoHandlers2.forEach(handle => handle(response.videoFile));
        if (response.endSession) {
          var _this$endSessionHandl2;
          (_this$endSessionHandl2 = this.endSessionHandlers) === null || _this$endSessionHandl2 === void 0 || _this$endSessionHandl2.forEach(handle => handle(response));
        }
        if (inputType) {
          if (this.settings.autoRunConversation && this.settings.useVoiceInput && !response.endSession && inputType == "Speech" && (!this.textToSpeechProvider || !this.settings.useOutputSpeech)) {
            var _this$speechToTextPro3;
            (_this$speechToTextPro3 = this.speechToTextProvider) === null || _this$speechToTextPro3 === void 0 || _this$speechToTextPro3.startListening();
          }
        }
        return response;
      } else {
        var _this$errorHandlers2;
        const error = await result.text();
        (_this$errorHandlers2 = this.errorHandlers) === null || _this$errorHandlers2 === void 0 || _this$errorHandlers2.forEach(handle => handle(error));
      }
      return null;
    } catch (e) {
      var _this$errorHandlers3;
      (_this$errorHandlers3 = this.errorHandlers) === null || _this$errorHandlers3 === void 0 || _this$errorHandlers3.forEach(handle => handle(e.toString()));
      return null;
    }
  }
  generateTextRequest(text, requestAttributes) {
    return {
      requestId: uuidv4(),
      user: this.generateUser(),
      device: this.generateDevice(),
      context: {
        channel: this.settings.channel,
        locale: this.settings.locale,
        sessionId: this.sessionId,
        requestType: "IntentRequest",
        originalInput: text,
        requiresLanguageUnderstanding: true,
        additionalSessionAttributes: this.sessionAttributes,
        additionalRequestAttributes: requestAttributes
      }
    };
  }
  generateWelcomeRequest(requestAttributes) {
    return {
      requestId: uuidv4(),
      user: this.generateUser(),
      device: this.generateDevice(),
      context: {
        channel: this.settings.channel,
        locale: this.settings.locale,
        sessionId: this.sessionId,
        requestType: "IntentRequest",
        requestName: "VoicifyWelcome",
        originalInput: "[Automated]",
        requiresLanguageUnderstanding: false,
        additionalSessionAttributes: this.sessionAttributes,
        additionalRequestAttributes: requestAttributes
      }
    };
  }
  generateUser() {
    return {
      id: this.userId,
      name: this.userId,
      additionalUserAttributes: this.userAttributes,
      accessToken: this === null || this === void 0 ? void 0 : this.accessToken
    };
  }
  generateDevice() {
    return {
      id: this.settings.device,
      name: this.settings.device,
      supportsDisplayText: true,
      supportsTextInput: true,
      supportsSsml: this.settings.useOutputSpeech,
      supportsVoiceInput: this.settings.useVoiceInput
    };
  }
}
// used to generate unique ids
const uuidv4 = () => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};
//# sourceMappingURL=VoicifyAssistant.js.map