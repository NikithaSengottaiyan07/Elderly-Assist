import Voice, { SpeechEndEvent, SpeechErrorEvent, SpeechRecognizedEvent, SpeechResultsEvent, SpeechStartEvent, SpeechVolumeChangeEvent } from '@react-native-voice/voice';
import type VoicifySpeechToTextProvider from './VoicifySpeechToTextProvider';
import { Platform } from 'react-native';

export class ReactNativeVoiceSTTProvider implements VoicifySpeechToTextProvider {
    locale: string
    speechResultsHandlers: ((fullResult: string) => void)[] = []
    speechErrorHandlers: ((error: string) => void)[] = []
    speechPartialHandlers: ((partialResult: string) => void)[] = []
    speechStartHandlers: ((error?: boolean) => void)[] = []
    speechRecognizedHandlers: ((isFinal: boolean) => void)[] = []
    speechEndHandlers: ((error?: boolean) => void)[] = []
    speechVolumeHandlers: ((value: number) => void)[] = []

    constructor(locale: string) {
        this.locale = locale;
    }

    initialize(locale: string) {
        this.locale = locale;
        let timeout: any
        //The react native voice package has a bug on ios where it does not wait 
        //for the person to stop talking before firing the callback function
        //this work around sets a timer and fires the handlers if no new words are deteced after 500 ms
        if (Platform.OS == "ios") {
            const onSpeechResults = (event: SpeechResultsEvent) => {
                Voice.cancel()
                Voice.stop()
                Voice.destroy()
                this.speechEndHandlers?.forEach(handle => handle(false));
                this.speechResultsHandlers?.forEach(handle => event.value && handle(event.value[0]));
            }
            Voice.onSpeechResults = (event: SpeechResultsEvent) => {
                if(!timeout)
                {
                    timeout = setTimeout(() => {
                        onSpeechResults(event)
                    }, 900)
                }
                else
                {
                    clearTimeout(timeout)
                    timeout = setTimeout(() => {
                        onSpeechResults(event)
                    }, 900)
                }
            }
        }
        else if (Platform.OS == "android") {
            Voice.onSpeechResults = (event: SpeechResultsEvent) => {
                this.speechResultsHandlers?.forEach(handle => event.value && handle(event.value[0]))
            }
        }


        Voice.onSpeechError = (event: SpeechErrorEvent) => {
            this.speechErrorHandlers?.forEach(handle => event.error?.message && handle(event.error.message))
        }
        Voice.onSpeechPartialResults = (event: SpeechResultsEvent) => {
            this.speechPartialHandlers?.forEach(handle => event.value && handle(event.value[0]))
        }
        Voice.onSpeechStart = (event?: SpeechStartEvent) => {
            this.speechStartHandlers?.forEach(handle => handle(event?.error));
        }
        Voice.onSpeechRecognized = (event: SpeechRecognizedEvent) => {
            this.speechRecognizedHandlers?.forEach(handle => event.isFinal && handle(event.isFinal));
        }
        Voice.onSpeechEnd = (event: SpeechEndEvent) => {
            this.speechEndHandlers?.forEach(handle => handle(event?.error));
        }
        Voice.onSpeechVolumeChanged = (event: SpeechVolumeChangeEvent) => {
            this.speechVolumeHandlers?.forEach(handle => event.value && handle(event.value));
        }
    }

    startListening() {
        Voice.start(this.locale)
    }

    stopListening() {
        Voice.stop()
    }

    cancelListening() {
        Voice.cancel()
    }

    destroyInstance() {
        Voice.destroy()
    }

    removeAllListeners() {
        Voice.removeAllListeners()
    }

    async isVoiceAvailable(): Promise<boolean> {
        const isVoiceAvailable = await Voice.isAvailable();
        if (isVoiceAvailable == 0) {
            return (false)
        }
        else {
            return (true)
        }
    }

    async isRecognizing(): Promise<boolean> {
        const isRecognizing = await Voice.isRecognizing();
        if (isRecognizing == 0) {
            return (false)
        }
        else {
            return (true)
        }
    }

    async getSpeechRecognitionServices(): Promise<string[]> {
        const services = await Voice.getSpeechRecognitionServices();
        if (services) {
            return (services)
        }
        else {
            return ([''])
        }
    }

    addFinishListener(callback: (fullResult: string) => void) {
        this.speechResultsHandlers?.push(callback);
    }

    addErrorListener(callback: (error: string) => void) {
        this.speechErrorHandlers?.push(callback);
    }

    addPartialListener(callback: (partialResult: string) => void) {
        this.speechPartialHandlers?.push(callback);
    }

    addStartListener(callback: (error?: boolean) => void) {
        this.speechStartHandlers?.push(callback)
    }

    addRecognizedListener(callback: (isFinal: boolean) => void) {
        this.speechRecognizedHandlers?.push(callback)
    }

    addEndListener(callback: (error?: boolean) => void) {
        this.speechEndHandlers?.push(callback)
    }

    addVolumeListener(callback: (value: number) => void) {
        this.speechVolumeHandlers?.push(callback)
    }

    clearHandlers() {
        this.speechResultsHandlers = []
        this.speechErrorHandlers = []
        this.speechPartialHandlers = []
        this.speechStartHandlers = []
        this.speechEndHandlers = []
        this.speechRecognizedHandlers = []
        this.speechVolumeHandlers = []
    }
}