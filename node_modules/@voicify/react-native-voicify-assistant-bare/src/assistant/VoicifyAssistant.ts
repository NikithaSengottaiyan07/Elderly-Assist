import type { CustomAssistantRequest, CustomAssistantResponse, CustomAssistantUser, MediaItemModel, VoicifySessionData, VoicifySessionEffect, VoicifyUserData } from "../models/customAssistantApiModels";
import type { InputType } from "./AssistantUITypes";
import type VoicifySpeechToTextProvider from "./VoicifySpeechToTextProvider";
import type VoicifyTextToSpeechProvider from "./VoicifyTextToSpeechProvider";
//TO DO: use the assistant SDK from NPM once it is ready instead of having seperate files
export class VoicifyAssistant {
    textToSpeechProvider?: VoicifyTextToSpeechProvider
    speechToTextProvider?: VoicifySpeechToTextProvider
    settings: VoicifyAssistantSettings
    sessionId?: string
    userId?: string
    accessToken?: string
    sessionAttributes?: { [key: string]: any; }
    userAttributes?: { [key: string]: any; }
    errorHandlers: ((e: string) => void)[] = []
    effectHandlers: { effect: string, callback: ((data: any) => void) }[] = []
    requestStartedHandlers: ((req: CustomAssistantRequest) => void)[] = []
    responseHandlers: ((res: CustomAssistantResponse) => void)[] = []
    endSessionHandlers: ((res: CustomAssistantResponse) => void)[] = []
    audioHandlers: ((media: MediaItemModel) => void)[] = []
    videoHandlers: ((media: MediaItemModel) => void)[] = []
    currentSessionInfo?: VoicifySessionData
    currentUserInfo?: VoicifyUserData

    constructor(settings: VoicifyAssistantSettings, ttsProvider?: VoicifyTextToSpeechProvider, sttProvider?: VoicifySpeechToTextProvider) {
        this.speechToTextProvider = sttProvider;
        this.textToSpeechProvider = ttsProvider;
        this.settings = settings;
    }

    initializeAndStart() {
        this.textToSpeechProvider?.initialize(this.settings.locale);
        this.speechToTextProvider?.initialize(this.settings.locale);
    }

    startNewSession(sessionId?: string, userId?: string, sessionAttributes?: { [key: string]: any; }, userAttributes?: { [key: string]: any; }) {
        this.sessionId = sessionId ?? uuidv4();
        this.userId = userId ?? this.userId ?? uuidv4();
        this.sessionAttributes = sessionAttributes;
        this.userAttributes = userAttributes;
        this.currentSessionInfo = {};
        this.currentUserInfo = {};
        if (this.settings?.initializeWithWelcomeMessage)
            this.makeWelcomeRequest();
    }

    onEffect(effectName: string, callback: (data: any) => void) {
        this.effectHandlers?.push({ effect: effectName, callback });
    }

    onError(callback: (error: string) => void) {
        this.errorHandlers?.push(callback);
    }

    onRequestStarted(callback: (request: CustomAssistantRequest) => void) {
        this.requestStartedHandlers?.push(callback);
    }

    onResponseReceived(callback: (response: CustomAssistantResponse) => void) {
        this.responseHandlers?.push(callback);
    }

    onSessionEnded(callback: (response: CustomAssistantResponse) => void) {
        this.endSessionHandlers?.push(callback);
    }

    onPlayVideo(callback: (mediaItem: MediaItemModel) => void) {
        this.videoHandlers?.push(callback);
    }

    onPlayAudio(callback: (mediaItem: MediaItemModel) => void) {
        this.audioHandlers?.push(callback);
    }

    clearHandlers() {
        this.audioHandlers = []
        this.videoHandlers = []
        this.responseHandlers = []
        this.requestStartedHandlers = []
        this.errorHandlers = []
        this.effectHandlers = []
        this.endSessionHandlers = []
    }

    makeTextRequest(text: string, requestAttributes?: { [key: string]: any; }, inputType?: InputType) {
        const request = this.generateTextRequest(text, requestAttributes);
        return this.makeRequest(request, inputType);
    }
    makeWelcomeRequest(requestAttributes?: { [key: string]: any; }) {
        const request = this.generateWelcomeRequest(requestAttributes);
        return this.makeRequest(request);
    }
    addSessionAttribute(key: string, value: any) {
        if (!this.sessionAttributes) this.sessionAttributes = {};
        this.sessionAttributes[key] = value;
    }
    addUserAttribute(key: string, value: any) {
        if (!this.userAttributes) this.userAttributes = {};
        this.userAttributes[key] = value;
    }
    addAccessToken(value: string) {
        this.accessToken = value;
    }
    async makeRequest(request: CustomAssistantRequest, inputType?: InputType) {
        try {
            this.textToSpeechProvider?.stop();
            this.requestStartedHandlers?.forEach(handle => handle(request));
            const result = await fetch(`${this.settings.serverRootUrl}/api/customAssistant/handlerequest?applicationId=${this.settings.appId}&applicationSecret=${this.settings.appKey}`, {
                method: "POST",
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(request)
            });
            if (result.status == 200) {
                const response = await result.json() as CustomAssistantResponse;
                this.textToSpeechProvider?.clearHandlers()
                this.textToSpeechProvider?.addFinishListener(() => {
                    if (inputType) {
                        (this.settings.autoRunConversation && this.settings.useVoiceInput && inputType == 'Speech' && this.settings.useOutputSpeech && this.speechToTextProvider && response.endSession == false) && this.speechToTextProvider?.startListening()
                    }
                })
                if (this.textToSpeechProvider && this.settings?.useOutputSpeech && (response.outputSpeech || response.ssml)) {
                    if (response.ssml) {
                        this.textToSpeechProvider.speakSsml(response.ssml)
                    }
                    else if (response.outputSpeech) {
                        this.textToSpeechProvider.speakSsml(`<speak>${response.outputSpeech}</speak>`)
                    }
                }


                const effectHandlers = this.effectHandlers;
                fetch(`${this.settings.serverRootUrl}/api/UserProfile/session/${this.sessionId}?applicationId=${this.settings.appId}&applicationSecret=${this.settings.appKey}`, {
                    method: "GET",
                    headers: {
                        'Content-Type': 'application/json',
                    },
                }).then(async sessionRes => {
                    if (sessionRes.status == 200) {
                        const sessionData = await sessionRes?.json() as VoicifySessionData;
                        if (sessionData) this.currentSessionInfo = sessionData;

                        // fire effects
                        // first check for response effects
                        let effects: Array<VoicifySessionEffect> = []
                        if(response?.effects?.length) {
                            effects = response.effects
                        }
                        // if no response effects, check for session effects
                        else {
                            effects = (sessionData?.sessionAttributes?.["effects"] ?? [])
                        }
                        
                        // fire effects if we have any
                        if(effects?.length)
                        {
                            // if we have the effect "name" prop, fire the response effects
                            if(effects[0]?.name)
                            {
                                effects.forEach(effect =>{
                                    effectHandlers.filter(e => e.effect == effect.name)?.forEach(handle => handle.callback(effect?.data)); 
                                })
                            }
                            // otherwise fire the session effects
                            else if (effects[0]?.effectName)
                            {
                                effects?.filter(e => e.requestId == request.requestId)?.forEach(effect => {
                                    effectHandlers.filter(e => e.effect == effect.effectName)?.forEach(handle => handle.callback(effect?.data));
                                })  
                            }
                        }                      
                    }
                });
                fetch(`${this.settings.serverRootUrl}/api/UserProfile/${this.userId}?applicationId=${this.settings.appId}&applicationSecret=${this.settings.appKey}`, {
                    method: "GET",
                    headers: {
                        'Content-Type': 'application/json',
                    },
                }).then(async userRes => {
                    if (userRes.status == 200) {
                        const userData = await userRes?.json() as VoicifyUserData;
                        if (userData) this.currentUserInfo = userData;
                    }
                });

                this.responseHandlers?.forEach(handle => handle(response));
                if (response?.audioFile)
                    this.audioHandlers?.forEach(handle => handle(response.audioFile!!));
                if (response?.videoFile)
                    this.videoHandlers?.forEach(handle => handle(response.videoFile!!));
                if (response.endSession) {
                    this.endSessionHandlers?.forEach(handle => handle(response));
                }
                if(inputType)
                {
                    if (this.settings.autoRunConversation && this.settings.useVoiceInput && !response.endSession && inputType == "Speech" && (!this.textToSpeechProvider || !this.settings.useOutputSpeech)) {
                        this.speechToTextProvider?.startListening()
                    }
                }
                
                return response;

            } else {
                const error = await result.text()
                this.errorHandlers?.forEach(handle => handle(error));
            }

            return null;

        } catch (e: any) {
            this.errorHandlers?.forEach(handle => handle(e.toString()));
            return null;
        }
    }
    generateTextRequest(text: string, requestAttributes?: { [key: string]: any; }): CustomAssistantRequest {
        return {
            requestId: uuidv4(),
            user: this.generateUser(),
            device: this.generateDevice(),
            context: {
                channel: this.settings.channel,
                locale: this.settings.locale,
                sessionId: this.sessionId as string,
                requestType: "IntentRequest",
                originalInput: text,
                requiresLanguageUnderstanding: true,
                additionalSessionAttributes: this.sessionAttributes,
                additionalRequestAttributes: requestAttributes
            }
        };
    }
    generateWelcomeRequest(requestAttributes?: { [key: string]: any; }): CustomAssistantRequest {
        return {
            requestId: uuidv4(),
            user: this.generateUser(),
            device: this.generateDevice(),
            context: {
                channel: this.settings.channel,
                locale: this.settings.locale,
                sessionId: this.sessionId as string,
                requestType: "IntentRequest",
                requestName: "VoicifyWelcome",
                originalInput: "[Automated]",
                requiresLanguageUnderstanding: false,
                additionalSessionAttributes: this.sessionAttributes,
                additionalRequestAttributes: requestAttributes
            }
        } as CustomAssistantRequest;
    }


    generateUser(): CustomAssistantUser {
        return {
            id: this.userId as string,
            name: this.userId,
            additionalUserAttributes: this.userAttributes,
            accessToken: this?.accessToken
        };
    }

    generateDevice() {
        return {
            id: this.settings.device,
            name: this.settings.device,
            supportsDisplayText: true,
            supportsTextInput: true,
            supportsSsml: this.settings.useOutputSpeech,
            supportsVoiceInput: this.settings.useVoiceInput
        };
    }


}
// used to generate unique ids
const uuidv4 = () => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
export interface VoicifyAssistantSettings {
    serverRootUrl: string

    appId: string

    appKey: string

    locale: string

    channel: string

    device: string

    // if we get an endSession false, open the mic again right away
    autoRunConversation: boolean

    // send the welcome message right on session start
    initializeWithWelcomeMessage: boolean

    // trigger speech on conversation turns
    useVoiceInput: boolean

    // run tts on each conversation turn
    useOutputSpeech: boolean

}
